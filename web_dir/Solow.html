<!DOCTYPE html>
<html>

<head>
    <title>Solow Diagram Simulation</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="styles.css">
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" type="text/css" href="style_index.css">
    <style>
        .regp {
            text-align: justify;
            margin-left: 35px;
            margin-right: 45px;
            padding-bottom: 35px;
        }
    </style>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</head>

<body style='margin-left: 50px; text-align: justify; font-family: calibri ; font-size: 22px'>


    <h1 style="text-align: center; font-family: Times New Roman; font-weight:lighter; margin-top: 50px"> Motivation
    </h1>

    <br>

    <blockquote class='basic_quote'
        cite="Solow, R. M. (1956). A contribution to the theory of economic growth. The quarterly journal of economics, 70(1), 65-94.">
        <p>"All
            theory depends on assumptions which are not quite true. That is what makes it theory. The art of successful
            theorizing is to make the inevitable
            simplifying assumptions in such a way that the final results are not very sensitive. A "crucial" assumption
            is one on which the conclusions do
            depend sensitively, and it is important that crucial assumptions be reasonably realistic. When the results
            of a theory seem to flow specifically
            from a special crucial assumption, then if the assumption is dubious, the results are suspect."
            <br><br>-<b style='font-family: Times new Roman; font-size: 22px; font-weight:550'>Solow, 1956</b>
        </p>
    </blockquote>

    <br>

    <p class='regp' style='margin-top: 40px'>
        These are the words of Robert M. Solow from his paper published in 1956, which introduced the Solow growth
        model.In this context, Solow refers to the "Harrod-Domar" growth model, which was primarily founded on the
        "crucial"
        assumption of "Fixed Proportions". The main aim behind developing the Solow growth model was to create a growth
        model akin to the Harrod-Domar model
        but without assuming "Fixed Proportions"

    </p>

    <p class='regp'>
        Solow achieves this by employing a slightly different framework while retaining all the assumptions of the
        Harrod-Domar model except for fixed proportions. He proposes that a single composite commodity (akin to domestic
        output) is produced by two inputs - <i>Labor</i> and <i>Capital</i> - under standard neoclassical conditions.
    </p>
    <br><br>
    <hr>
    <br><br>
    <h1 style="text-align: center; font-family: Times New Roman; font-weight: lighter;">Components of the Model</h1>

    <br>
    <br>

    <p class='regp'>
        Here, we discuss the various components or variables that are used in the development of the Solow model.
    </p>
    <br>

    <ol>

        <li>
            <p class='regp'>
                <b style='text-decoration: underline; font-size: 24px;'>Output</b>- This can be thought of as the
                collection of output produced by the nation. We give the <b><i>rate</i></b> of it's production by <b
                    style='font-family: segoe UI'>\( Y(t) \)</b> - which denotes the amount of output produced in a unit
                of
                time. This can also be thought of as the GDP. On the other hand production possibilities are represented
                by the function<br><br>

            <p style='text-align: center'>\( Y = F(K, L) \quad \text{...(1)} \)</p>

            <br><br>
            <p class='regp'>Here, we assume the production function to be of the Cobb-Douglas type. It is increasing,
                concave and
                exhibits constant returns to scale. This implies that the the Marginal Product of both Labor
                and Capital is decreasing- high level of production can be achieved only by increasing both inputs.</p>
        </li>
        </p>

        <br>
        <li>
            <p class='regp'>
                <b style='text-decoration: underline; font-size: 24px;'>Depreciation</b> - We denote the rate of
                depreciation by \( \delta \). Another approach would be to subsume depreciation in the output itself
                (which
                is how Solow does in his 1956 paper), but he former is
                more lucid. The rate of depreciation is constant.
            </p>
        </li>
        <br>
        <li>
            <p class='regp'>
                <b style='text-decoration: underline; font-size: 24px;'>Capital Stock</b> - The Capital Stock, denoted
                by \( K(t) \), can be thought of as the accumulation of the composite commodity over time- the rate of
                which
                is given by \( \dot{K}\). <br><br>\( \dot{K}\) can be thought of as the
                rate of investment. Here, we make the assumption of full employment of capital stock. That is, at any
                point of time, the pre-existing stock of capital is inelastically supplied.
            </p>
        </li>

    </ol>


    <br><br>
    <hr>
    <br><br>

    <h1 style="text-align: center; font-family: Times New Roman; font-weight: lighter;">Derivation of the Equilibrium
        condition</h1>
    <br><br>

    <p class='regp'>This is the derivation of the equilibrium equation.<br></p>

    <p class='regp'>We assume that a constant part of the output produced is saved and subsequently invested. That is,
    </p>

    <p style='text-align: center'>\( S = s \cdot Y \)</p>

    <p class='regp'>We know that in neoclassical theory, planned savings is equal to planned investment.</p>

    <p class='regp'>Now, planned investment - given by \(\dot{K}\) - can be obtained by subtracting depreciation from
        savings</p>

    <p class='regp'>\( \dot{K} = s \cdot F(K, L) - D \quad \text{...(1)} \)</p>

    <p class='regp'>where depreciation occurs as a certain percentage of capital stock. That is \( D = \delta \cdot K \)
    </p>
    <p class='regp'>We assume the labor grows exponentially at the rate \( n \):</p>

    <p style='text-align: center'>\( L(t) = L_0 \cdot e^{nt} \quad \text{...(2)} \)</p>

    <p class='regp'>Substituting in (1), we get</p>

    <p style='text-align: center'>\( \dot{K} = s \cdot F(K, L_0 e^{nt}) - \delta \cdot K \)</p>

    <p class='regp'>Now, we define a new variable \( r \), where \( r = \frac{K}{L} \) is the capital-labor ratio, or
        the capital per
        labor. We try to express (3) in terms of one variable \( r \).</p>

    <p style='text-align: center'>\( r = \frac{K}{L} \)</p><br>

    <p style='text-align: center'>\( K = r \cdot L \)</p>

    <p class='regp'>Substituting \( L \) from (2):</p>

    <p style='text-align: center'>\( K = r \cdot L_0 e^{nt} \)</p>

    <p class='regp'>Differentiating \( K \) with respect to \( t \), we get:</p>

    <p style='text-align: center'>\( \dot{K} = r \cdot n \cdot L_0 e^{nt} + \dot{r} \cdot L_0 e^{nt} \)</p>

    <p class='regp'>Factoring out \( L_0 e^{nt} \):</p>

    <p style='text-align: center'>\( \dot{K} = L_0 e^{nt} \cdot (r \cdot n + \dot{r}) \)</p>

    <p class='regp'>From (1), we have:</p>

    <p style='text-align: center'>\( s \cdot F(K, L) - \delta \cdot K = L_0 e^{nt} \cdot (r \cdot n + \dot{r}) \)</p>
    <p class='regp'>Now, we divide both sides by \( L \). Since \( F \) is a homogeneous function of the first degree,
        we get</p>

    <p style='text-align: center'>\( s \cdot F(r, 1) - \delta \cdot K = r(n + \dot{r}) \)</p>

    <p class='regp'>Simplifying, we get:</p>

    <p style='text-align: center'>\( \dot{r} = s \cdot F(r, 1) - r(n + \delta) \quad \text{...(5)} \)</p>

    <p class='regp'>Equation (5) is our final equation. This equation is the equilibrium condition. Upon a closer look,
        on the RHS,
        the \( F(r, 1) \) component is the output per labor, and \( s \cdot F(r, 1) \) is the savings per labor. The
        second term \( r n \) is the rate of growth of investment. Equation (5) basically states that the "growth rate
        in savings must be equal to the growth rate of investment in order to achieve equilibrium."</p>

<hr>

<h1 style="text-align: center; font-family: Times New Roman; font-weight:lighter; margin-top: 50px; margin-bottom: 250px; margin-top: 70px;">Solow Diagram Simulation</h1>
<div id="chart" style="display: inline-block;"></div>
<div id="inputs" style="display: inline-block; vertical-align: top; margin-left: 20px;">
    <div>
        <label for="alpha">Alpha (\(\alpha\)):</label>
        <input type="number" id="alpha" min="0" max="1" step="0.01" value="0.3">
    </div>
    <div>
        <label for="K">Capital (K):</label>
        <input type="number" id="K" min="1" max="5" step="1" value="2">
    </div>
    <div>
        <label for="L">Labor (L):</label>
        <input type="number" id="L" min="1" max="100" step="1" value="10">
    </div>
    <div>
        <label for="w">Wage Rate (w):</label>
        <input type="number" id="w" min="10" max="25" step="0.01" value="15">
    </div>
    <div>
        <label for="s">Savings Rate (s):</label>
        <input type="number" id="s" min="1" max="100" step="1" value="20">
    </div>
    <div>
        <label for="n">Population Growth Rate (n):</label>
        <input type="number" id="n" min="1" max="35" step="1" value="10">
    </div>
</div>

<script>
    const margin = { top: 40, right: 40, bottom: 60, left: 60 };
    const width = 800 - margin.left - margin.right;
    const height = 600 - margin.top - margin.bottom;
    const transitionDuration = 2000; // 2 seconds transition duration

    const svg = d3.select("#chart")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", `translate(${margin.left}, ${margin.top})`);

    const xScale = d3.scaleLinear()
        .range([0, width]);

    const yScale = d3.scaleLinear()
        .range([height, 0]);

    const xAxis = d3.axisBottom(xScale);
    const yAxis = d3.axisLeft(yScale);

    svg.append("g")
        .attr("class", "x axis")
        .attr("transform", `translate(0, ${height})`)
        .call(xAxis);

    svg.append("g")
        .attr("class", "y axis")
        .call(yAxis);


    svg.append("text")
        .attr("x", width / 2)
        .attr("y", height + margin.bottom - 10)
        .style("text-anchor", "middle")
        .text("Capital per Worker (k)");

    svg.append("text")
        .attr("x", -height / 2)
        .attr("y", -margin.left + 20)
        .attr("transform", "rotate(-90)")
        .style("text-anchor", "middle")
        .text("Output per Worker (y)");

    const productioncurve = d3.line()
        .x(d => xScale(d.k))
        .y(d => yScale(d.y));

    const investmentcurve = d3.line()
        .x(d => xScale(d.k))
        .y(d => yScale(d.s));

    const steadystatecurve = d3.line()
        .x(d => xScale(d.k))
        .y(d => yScale(d.n_delta));

    const updateChart = () => {
        const alpha = parseFloat(d3.select("#alpha").property("value"));
        const K = parseInt(d3.select("#K").property("value"));
        const L = parseInt(d3.select("#L").property("value"));
        const w = parseFloat(d3.select("#w").property("value"));
        const s = parseFloat(d3.select("#s").property("value")) / 100;
        const n = parseFloat(d3.select("#n").property("value")) / 100;
        const delta = 0.05;
        const r = 125;

        const Y = Math.pow(K, alpha) * Math.pow(L, 1 - alpha);
        const y = Y / L;
        const k = K / L;
        const k_dot = s * y - (n + delta) * k;

        const data = [];
        const k_range = d3.range(0.01, 5.01, 0.01);

        k_range.forEach(k_value => {
            const y_value = Math.pow(k_value, alpha);
            const s_value = s * Math.pow(k_value, alpha);
            const n_delta_value = (n + delta) * k_value;
            data.push({ k: k_value, y: y_value, s: s_value, n_delta: n_delta_value });
        });

        xScale.domain(d3.extent(data, d => d.k));
        yScale.domain([0, d3.max(data, d => Math.max(d.y, d.s, d.n_delta)) * 1.2]);

        svg.select(".x.axis")
            .transition()
            .duration(transitionDuration)
            .call(xAxis);

        svg.select(".y.axis")
            .transition()
            .duration(transitionDuration)
            .call(yAxis);


        const prodcurvePath = svg.selectAll(".prodcurve")
            .data([data])
            .join("path")
            .attr("class", "line prodcurve")
            .attr("d", productioncurve)
            .attr("stroke", "steelblue")
            .attr("fill", "none")
            .transition()
            .duration(transitionDuration)
            .attrTween("d", function (d) {
                const previous = d3.select(this).attr("d");
                const current = productioncurve(d);
                return d3.interpolatePath(previous, current);
            });

        const investcurvePath = svg.selectAll(".investcurve")
            .data([data])
            .join("path")
            .attr("class", "line investcurve")
            .attr("d", investmentcurve)
            .attr("stroke", "green")
            .attr("fill", "none")
            .transition()
            .duration(transitionDuration)
            .attrTween("d", function (d) {
                const previous = d3.select(this).attr("d");
                const current = investmentcurve(d);
                return d3.interpolatePath(previous, current);
            });

        const steadystatePath = svg.selectAll(".steadystate")
            .data([data])
            .join("path")
            .attr("class", "line steadystate")
            .attr("d", steadystatecurve)
            .attr("stroke", "red")
            .attr("fill", "none")
            .transition()
            .duration(transitionDuration)
            .attrTween("d", function (d) {
                const previous = d3.select(this).attr("d");
                const current = steadystatecurve(d);
                return d3.interpolatePath(previous, current);
            });

        const currentK = svg.selectAll(".currentK")
            .data([{ k: k }])
            .join("line")
            .attr("class", "currentK")
            .attr("x1", d => xScale(d.k))
            .attr("x2", d => xScale(d.k))
            .attr("y1", 0)
            .attr("y2", height)
            .attr("stroke", "black")
            .attr("stroke-dasharray", "5,5")
            .transition()
            .duration(transitionDuration)
            .attr("x1", d => xScale(d.k))
            .attr("x2", d => xScale(d.k));

        const annotation = svg.selectAll(".annotation")
            .data([{ k: k, k_dot: k_dot }])
            .join("text")
            .attr("class", "annotation")
            .attr("x", width * 0.1)
            .attr("y", height * 0.9)
            .text(d => {
                if (d.k_dot > 0) {
                    return "Capital deepening";
                } else if (d.k_dot < 0) {
                    return "Capital widening";
                } else {
                    return "Steady state";
                }
            });
    };

    d3.selectAll("input")
        .on("input", updateChart);

    updateChart();
</script>

</body>

</html>